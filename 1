import os
import shlex
import subprocess
import uuid
import math
import re
import shutil
from pathlib import Path
from typing import List, Tuple, Optional
from datetime import datetime

from telegram import Update, InputFile
from telegram.ext import Updater, CommandHandler, MessageHandler, Filters, CallbackContext

# Optional: Whisper import
try:
    import whisper
except ImportError:
    whisper = None

# ---------- Configuration ----------
TELEGRAM_BOT_TOKEN = os.environ.get('TELEGRAM_BOT_TOKEN')
WORKDIR = Path(os.environ.get('WORKDIR', './work')).absolute()
MAX_CLIP_SECONDS = 50
MAX_FILE_SIZE = 500 * 1024 * 1024  # 500MB
MAX_VIDEO_DURATION = 3600  # 1 hour
MAX_VIDEO_SIZE_MB = 50  # Telegram file size limit

# Create work directory
WORKDIR.mkdir(parents=True, exist_ok=True)

# ---------- Helper functions ----------

def sanitize_filename(filename: str) -> str:
    """Prevent path traversal attacks and sanitize filenames."""
    clean_name = re.sub(r'[^a-zA-Z0-9\-_\.]', '_', os.path.basename(filename))
    return clean_name[:100]

def validate_video_file(path: Path) -> Tuple[bool, str]:
    """Check if video is within acceptable limits."""
    try:
        if not path.exists():
            return False, "File does not exist"
        
        if path.stat().st_size > MAX_FILE_SIZE:
            return False, f"File too large ({path.stat().st_size / 1024 / 1024:.1f}MB > {MAX_FILE_SIZE / 1024 / 1024:.1f}MB)"
        
        duration = get_video_duration(path)
        if duration > MAX_VIDEO_DURATION:
            return False, f"Video too long ({duration:.1f}s > {MAX_VIDEO_DURATION}s)"
        
        return True, "Valid"
    except Exception as e:
        return False, f"Validation error: {str(e)}"

def run(cmd: List[str], capture_output=False, timeout=300):
    """Run a shell command (list form). Raises on error."""
    print('RUN:', ' '.join(shlex.quote(p) for p in cmd))
    try:
        proc = subprocess.run(cmd, capture_output=capture_output, text=True, timeout=timeout)
        if proc.returncode != 0:
            raise RuntimeError(f"Command failed: {' '.join(cmd)}\nstdout={proc.stdout}\nstderr={proc.stderr}")
        return proc
    except subprocess.TimeoutExpired:
        raise RuntimeError(f"Command timed out after {timeout} seconds: {' '.join(cmd)}")

def download_with_ytdlp(url: str, out_dir: Path) -> Path:
    """Download video using yt-dlp to out_dir and return path to downloaded file."""
    out_dir.mkdir(parents=True, exist_ok=True)
    filename_template = str(out_dir / '%(title).100s-%(id)s.%(ext)s')
    cmd = [
        'yt-dlp', 
        '-f', 'best[height<=1080]/best',
        '--merge-output-format', 'mp4', 
        '--no-playlist',
        '-o', filename_template, 
        url
    ]
    run(cmd)
    
    files = sorted(out_dir.glob('*'), key=lambda p: p.stat().st_mtime, reverse=True)
    if not files:
        raise FileNotFoundError('yt-dlp did not produce a file')
    
    is_valid, message = validate_video_file(files[0])
    if not is_valid:
        raise RuntimeError(f"Downloaded video validation failed: {message}")
    
    return files[0]

def get_video_dimensions(path: Path) -> Tuple[int, int]:
    """Get video width and height."""
    cmd = ['ffprobe', '-v', 'error', '-select_streams', 'v:0', 
           '-show_entries', 'stream=width,height', '-of', 'csv=p=0', str(path)]
    proc = run(cmd, capture_output=True)
    width, height = map(int, proc.stdout.strip().split(','))
    return width, height

def convert_to_9_16_enhanced(input_path: Path, output_path: Path, target_height=1920):
    """Enhanced conversion to 9:16 with better handling of different aspect ratios."""
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    try:
        width, height = get_video_dimensions(input_path)
        aspect_ratio = width / height
        
        target_width = int(target_height * 9 / 16)
        
        if aspect_ratio > 1.7:
            vf = f"crop=ih*9/16:ih:({width}-ih*9/16)/2:0,scale={target_width}:{target_height}:flags=lanczos"
        elif aspect_ratio < 0.7:
            vf = f"scale={target_width}:-2:flags=lanczos,pad={target_width}:{target_height}:(ow-iw)/2:(oh-ih)/2:color=black"
        else:
            vf = (f"split=2[bg][vid];[bg]scale={target_width}:{target_height}:flags=lanczos,gblur=sigma=20[bg];"
                  f"[vid]scale=-2:{target_height}:flags=lanczos[vid];[bg][vid]overlay=(W-w)/2:(H-h)/2")
        
        cmd = [
            'ffmpeg', '-y', '-i', str(input_path), 
            '-vf', vf,
            '-c:v', 'libx264', '-preset', 'medium', '-crf', '23',
            '-c:a', 'aac', '-b:a', '128k',
            '-movflags', '+faststart',
            '-f', 'mp4', str(output_path)
        ]
        run(cmd)
        return output_path
    except Exception as e:
        print(f"Enhanced conversion failed, using fallback: {e}")
        return convert_to_9_16_fallback(input_path, output_path, target_height)

def convert_to_9_16_fallback(input_path: Path, output_path: Path, target_height=1920):
    """Fallback conversion method."""
    target_width = int(target_height * 9 / 16)
    vf = f"scale={target_width}:{target_height}:force_original_aspect_ratio=decrease:flags=lanczos,pad={target_width}:{target_height}:(ow-iw)/2:(oh-ih)/2:color=black"
    
    cmd = [
        'ffmpeg', '-y', '-i', str(input_path), 
        '-vf', vf,
        '-c:v', 'libx264', '-preset', 'medium', '-crf', '23',
        '-c:a', 'aac', '-b:a', '128k',
        '-movflags', '+faststart', str(output_path)
    ]
    run(cmd)
    return output_path

def get_video_duration(path: Path) -> float:
    """Return duration in seconds using ffprobe."""
    cmd = [
        'ffprobe', '-v', 'error', 
        '-show_entries', 'format=duration', 
        '-of', 'default=noprint_wrappers=1:nokey=1', 
        str(path)
    ]
    proc = run(cmd, capture_output=True)
    return float(proc.stdout.strip())

def split_into_clips(input_path: Path, out_dir: Path, max_seconds=MAX_CLIP_SECONDS) -> List[Path]:
    """Split input video into clips each <= max_seconds. Returns list of clip paths."""
    out_dir.mkdir(parents=True, exist_ok=True)
    duration = get_video_duration(input_path)
    
    if duration <= max_seconds:
        out_path = out_dir / f"{input_path.stem}_full.mp4"
        run(['cp', str(input_path), str(out_path)])
        return [out_path]
    
    clip_paths = []
    num_clips = math.ceil(duration / max_seconds)
    base = sanitize_filename(input_path.stem)
    
    for i in range(num_clips):
        start = i * max_seconds
        length = min(max_seconds, duration - start)
        out_path = out_dir / f"{base}_part{i+1:02d}.mp4"
        
        cmd = [
            'ffmpeg', '-y', '-i', str(input_path), 
            '-ss', str(start), '-t', str(length),
            '-c', 'copy',
            '-avoid_negative_ts', 'make_zero',
            str(out_path)
        ]
        run(cmd)
        clip_paths.append(out_path)
    
    return clip_paths

def optimize_for_shorts(input_path: Path, output_path: Path):
    """Apply Shorts-specific optimizations."""
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    cmd = [
        'ffmpeg', '-y', '-i', str(input_path),
        '-c:v', 'libx264', '-profile:v', 'main', '-level', '3.1',
        '-crf', '21', '-preset', 'fast',
        '-c:a', 'aac', '-b:a', '128k',
        '-movflags', '+faststart',
        '-vf', 'fps=30,format=yuv420p',
        '-max_muxing_queue_size', '1024',
        str(output_path)
    ]
    run(cmd)
    return output_path

def transcribe_with_whisper(clip_path: Path, model_name='base') -> List[dict]:
    """Transcribe audio and return segments list with start, end, text."""
    if whisper is None:
        raise RuntimeError('Whisper package is not available. Install "openai-whisper" (and torch).')
    
    try:
        if not clip_path.exists():
            raise RuntimeError(f"Audio file not found: {clip_path}")
            
        model = whisper.load_model(model_name)
        print(f'Transcribing {clip_path}')
        result = model.transcribe(
            str(clip_path),
            fp16=False,
            verbose=True
        )
        segments = result.get('segments', [])
        
        if not segments:
            raise RuntimeError("No speech segments detected in audio")
            
        return segments
    except Exception as e:
        raise RuntimeError(f"Whisper transcription failed: {str(e)}")

def write_srt(segments: List[dict], srt_path: Path):
    """Write segments to SRT subtitle file."""
    def fmt_time(t):
        h = int(t // 3600)
        m = int((t % 3600) // 60)
        s = int(t % 60)
        ms = int((t - int(t)) * 1000)
        return f"{h:02d}:{m:02d}:{s:02d},{ms:03d}"
    
    srt_path.parent.mkdir(parents=True, exist_ok=True)
    
    with srt_path.open('w', encoding='utf-8') as f:
        for i, seg in enumerate(segments, start=1):
            start = fmt_time(seg['start'])
            end = fmt_time(seg['end'])
            text = seg['text'].strip()
            f.write(f"{i}\n{start} --> {end}\n{text}\n\n")

def burn_subtitles(clip_path: Path, srt_path: Path, out_path: Path):
    """Burn subtitles into video with nice styling."""
    out_path.parent.mkdir(parents=True, exist_ok=True)
    
    subtitle_style = (
        "force_style="
        "FontName=Arial,"
        "FontSize=24,"
        "PrimaryColour=&H00FFFFFF,"
        "OutlineColour=&H00000000,"
        "BackColour=&H80000000,"
        "Bold=1,"
        "MarginV=50"
    )
    
    cmd = [
        'ffmpeg', '-y', '-i', str(clip_path),
        '-vf', f"subtitles={shlex.quote(str(srt_path))}:{subtitle_style}",
        '-c:a', 'copy', str(out_path)
    ]
    run(cmd)
    return out_path

def cleanup_old_files(max_age_hours=24):
    """Clean up files older than specified hours."""
    try:
        cutoff_time = datetime.now().timestamp() - (max_age_hours * 3600)
        for item in WORKDIR.glob('*'):
            if item.is_dir() and item.stat().st_mtime < cutoff_time:
                shutil.rmtree(item)
                print(f"Cleaned up old directory: {item}")
    except Exception as e:
        print(f"Cleanup error: {e}")

# ---------- Telegram bot handlers ----------

def start(update: Update, context: CallbackContext):
    """Handle /start command."""
    help_text = """
üé¨ *YouTube Shorts Converter Bot*

*Send me:*
‚Ä¢ A YouTube/TikTok/Instagram video URL
‚Ä¢ Or a video file (up to 50MB)

*I will:*
1. Convert to vertical 9:16 format
2. Split into ‚â§50 second clips
3. Add automatic captions
4. Optimize for YouTube Shorts

*Commands:*
/start - Show this help
/cleanup [hours] - Clean up old files
/sendclips - Send all clips from clips directory

Just send me a video link or file to get started!
    """
    update.message.reply_text(help_text, parse_mode='Markdown')

def sendclips(update: Update, context: CallbackContext):
    """Handle /sendclips command - Send all clips from bot-generated clip directories."""
    chat_id = update.message.chat_id
    
    status_msg = update.message.reply_text('üîç Searching for bot-generated clips...')
    
    try:
        # Find all session directories
        session_dirs = [d for d in WORKDIR.glob('*') if d.is_dir() and len(d.name) == 8]
        
        if not session_dirs:
            status_msg.edit_text("‚ùå No bot sessions found. Process some videos first!")
            return
        
        # Collect all clips from all session directories
        all_clip_files = []
        for session_dir in session_dirs:
            clips_dir = session_dir / 'clips'
            output_dir = session_dir / 'output'
            
            # Look for clips in both clips and output directories
            if clips_dir.exists():
                session_clips = list(clips_dir.glob("*.mp4"))
                all_clip_files.extend(session_clips)
            
            if output_dir.exists():
                output_clips = list(output_dir.glob("*.mp4"))
                all_clip_files.extend(output_clips)
        
        if not all_clip_files:
            status_msg.edit_text("‚ùå No clip files found in any session directories.")
            return
        
        # Sort by modification time (newest first)
        all_clip_files.sort(key=lambda x: x.stat().st_mtime, reverse=True)
        
        status_msg.edit_text(f'üìÅ Found {len(all_clip_files)} clip(s) across {len(session_dirs)} sessions. Starting upload...')
        
        successful_uploads = 0
        failed_uploads = 0
        
        for i, clip_path in enumerate(all_clip_files):
            try:
                status_msg.edit_text(f'üì§ Uploading clip {i+1}/{len(all_clip_files)}: {clip_path.name}...')
                
                if not clip_path.exists():
                    print(f"Clip file not found: {clip_path}")
                    failed_uploads += 1
                    continue
                    
                # Validate file size before sending
                file_size = clip_path.stat().st_size
                if file_size > MAX_VIDEO_SIZE_MB * 1024 * 1024:
                    compressed_path = clip_path.parent / f"compressed_{clip_path.name}"
                    optimize_for_shorts(clip_path, compressed_path)
                    clip_path = compressed_path
                
                with clip_path.open('rb') as fh:
                    context.bot.send_video(
                        chat_id=chat_id,
                        video=InputFile(fh, filename=clip_path.name),
                        supports_streaming=True,
                        timeout=600,
                        caption=f"Clip: {clip_path.name}"
                    )
                successful_uploads += 1
                
            except Exception as e:
                print(f"Error uploading {clip_path}: {e}")
                failed_uploads += 1
        
        summary = f"üìä Upload Summary:\n‚úÖ Successful: {successful_uploads}\n‚ùå Failed: {failed_uploads}"
        status_msg.edit_text(summary)
        
    except Exception as e:
        error_msg = f"‚ùå Error searching for clips: {str(e)}"
        print(f"Sendclips error: {e}")
        status_msg.edit_text(error_msg)

def cleanup(update: Update, context: CallbackContext):
    """Handle /cleanup command - Clean up old files and directories."""
    try:
        # Get cleanup age from command arguments (default: 24 hours)
        hours = 24
        if context.args:
            try:
                hours = int(context.args[0])
                if hours < 1:
                    hours = 1
            except ValueError:
                pass
        
        status_msg = update.message.reply_text(f'üßπ Starting cleanup (older than {hours} hours)...')
        
        cutoff_time = datetime.now().timestamp() - (hours * 3600)
        deleted_files = 0
        deleted_dirs = 0
        total_freed = 0
        
        # Clean up old session directories
        for item in WORKDIR.glob('*'):
            if item.is_dir() and item.stat().st_mtime < cutoff_time:
                try:
                    dir_size = sum(f.stat().st_size for f in item.rglob('*') if f.is_file())
                    shutil.rmtree(item)
                    deleted_dirs += 1
                    total_freed += dir_size
                except Exception as e:
                    print(f"Error cleaning up {item}: {e}")
        
        # Also clean up any loose files in workdir
        for item in WORKDIR.glob('*'):
            if item.is_file() and item.stat().st_mtime < cutoff_time:
                try:
                    total_freed += item.stat().st_size
                    item.unlink()
                    deleted_files += 1
                except Exception as e:
                    print(f"Error deleting file {item}: {e}")
        
        report = (
            f"‚úÖ Cleanup completed!\n"
            f"‚Ä¢ Deleted directories: {deleted_dirs}\n"
            f"‚Ä¢ Deleted files: {deleted_files}\n"
            f"‚Ä¢ Freed space: {total_freed/1024/1024:.1f} MB\n"
            f"‚Ä¢ Age threshold: {hours} hours"
        )
        
        status_msg.edit_text(report)
        
    except Exception as e:
        error_msg = f"‚ùå Cleanup failed: {str(e)}"
        print(f"Cleanup error: {e}")
        update.message.reply_text(error_msg)

def process_video_url(update: Update, context: CallbackContext):
    """Process video from URL."""
    url = update.message.text.strip()
    chat_id = update.message.chat_id
    
    if not re.match(r'^https?://', url):
        update.message.reply_text("‚ùå Please provide a valid URL starting with http:// or https://")
        return
    
    status_msg = update.message.reply_text('üì• Got your link ‚Äî starting processing...')
    
    try:
        session_id = uuid.uuid4().hex[:8]
        base_dir = WORKDIR / session_id
        downloads = base_dir / 'downloads'
        
        downloads.mkdir(parents=True, exist_ok=True)

        # Download
        status_msg.edit_text('üì• Downloading video...')
        input_video = download_with_ytdlp(url, downloads)

        # Process the video
        return process_video_file(update, context, input_video, base_dir, status_msg)
        
    except Exception as exc:
        error_msg = f"‚ùå Processing failed: {str(exc)}"
        print(f"Error processing URL: {exc}")
        status_msg.edit_text(error_msg)

def handle_video_file(update: Update, context: CallbackContext):
    """Handle video files sent directly to the bot."""
    chat_id = update.message.chat_id
    
    video = update.message.video or update.message.document
    if video.file_size > MAX_VIDEO_SIZE_MB * 1024 * 1024:
        update.message.reply_text(f"‚ùå File too large. Maximum size is {MAX_VIDEO_SIZE_MB}MB.")
        return
    
    status_msg = update.message.reply_text('üì• Downloading your video...')
    
    try:
        session_id = uuid.uuid4().hex[:8]
        base_dir = WORKDIR / session_id
        downloads = base_dir / 'downloads'
        downloads.mkdir(parents=True, exist_ok=True)

        # Download file from Telegram
        file_obj = context.bot.get_file(video.file_id)
        local_path = downloads / f"{video.file_id}.mp4"
        file_obj.download(custom_path=str(local_path))

        # Validate the downloaded file
        is_valid, message = validate_video_file(local_path)
        if not is_valid:
            raise RuntimeError(f"Invalid video file: {message}")

        # Process the video
        return process_video_file(update, context, local_path, base_dir, status_msg)
        
    except Exception as exc:
        error_msg = f"‚ùå Processing failed: {str(exc)}"
        print(f"Error handling file: {exc}")
        status_msg.edit_text(error_msg)

def process_video_file(update: Update, context: CallbackContext, input_video: Path, base_dir: Path, status_msg):
    """Common processing pipeline for both URLs and files."""
    chat_id = update.message.chat_id
    converted = base_dir / 'converted'
    clips = base_dir / 'clips'
    output = base_dir / 'output'
    
    # Create all directories upfront
    converted.mkdir(parents=True, exist_ok=True)
    clips.mkdir(parents=True, exist_ok=True)
    output.mkdir(parents=True, exist_ok=True)
    
    try:
        # Convert to 9:16
        status_msg.edit_text('üîÑ Converting to vertical format...')
        converted_path = converted / f"{input_video.stem}_9_16.mp4"
        convert_to_9_16_enhanced(input_video, converted_path)

        # Split into clips
        status_msg.edit_text('‚úÇÔ∏è Splitting into Shorts-friendly clips...')
        clip_paths = split_into_clips(converted_path, clips, max_seconds=MAX_CLIP_SECONDS)

        if not clip_paths:
            raise RuntimeError("No clips were generated")

        generated = []
        
        for i, clip_path in enumerate(clip_paths):
            status_msg.edit_text(f'üéôÔ∏è Processing clip {i+1}/{len(clip_paths)}...')
            
            try:
                # Try transcription and captioning
                segments = transcribe_with_whisper(clip_path)
                srt_path = output / f"{clip_path.stem}.srt"
                write_srt(segments, srt_path)
                
                captioned_path = output / f"{clip_path.stem}_captioned.mp4"
                burn_subtitles(clip_path, srt_path, captioned_path)
                
                final_path = output / f"{clip_path.stem}_final.mp4"
                optimize_for_shorts(captioned_path, final_path)
                
                generated.append(final_path)
                
            except Exception as e:
                print(f'Error processing clip {clip_path}: {e}')
                # Fallback: use original clip without captions
                fallback_path = output / f"{clip_path.stem}_nocaptions.mp4"
                optimize_for_shorts(clip_path, fallback_path)
                generated.append(fallback_path)

        # Send results
        status_msg.edit_text(f'üì§ Uploading {len(generated)} clip(s)...')
        
        for i, final_clip in enumerate(generated):
            if not final_clip.exists():
                continue
                
            status_msg.edit_text(f'üì§ Uploading clip {i+1}/{len(generated)}...')
            
            with final_clip.open('rb') as fh:
                context.bot.send_video(
                    chat_id=chat_id,
                    video=fh,
                    supports_streaming=True,
                    timeout=600,
                    caption=f"Short #{i+1} (Generated by YouTube Shorts Bot)"
                )
        
        status_msg.edit_text(f'‚úÖ Successfully processed and sent {len(generated)} clip(s)!')
        
        # Send summary
        total_duration = sum(get_video_duration(clip) for clip in generated if clip.exists())
        update.message.reply_text(
            f"üìä Summary:\n"
            f"‚Ä¢ Clips generated: {len(generated)}\n"
            f"‚Ä¢ Total duration: {total_duration:.1f}s\n"
            f"‚Ä¢ Session ID: {base_dir.name}\n"
            f"üóëÔ∏è Files will be automatically cleaned up after 24 hours."
        )
        
    except Exception as exc:
        error_msg = f"‚ùå Processing failed: {str(exc)}"
        print(f"Error in process_video_file: {exc}")
        status_msg.edit_text(error_msg)

def error_handler(update: Update, context: CallbackContext):
    """Handle errors in the bot."""
    print(f"Error: {context.error}")
    if update and update.message:
        update.message.reply_text("‚ùå An unexpected error occurred. Please try again.")

# ---------- Main ----------

def main():
    """Start the bot."""
    if not TELEGRAM_BOT_TOKEN:
        print('‚ùå Please set TELEGRAM_BOT_TOKEN environment variable.')
        return
    
    print('ü§ñ Starting YouTube Shorts Converter Bot...')
    print(f'üìÅ Work directory: {WORKDIR}')
    print(f'‚è∞ Max clip duration: {MAX_CLIP_SECONDS}s')
    
    # Clean up old files on startup
    cleanup_old_files()
    
    try:
        updater = Updater(TELEGRAM_BOT_TOKEN, use_context=True)
        dp = updater.dispatcher
        
        # Add handlers
        dp.add_handler(CommandHandler("start", start))
        dp.add_handler(CommandHandler("cleanup", cleanup))
        dp.add_handler(CommandHandler("sendclips", sendclips))
        dp.add_handler(MessageHandler(Filters.entity("url") & Filters.text, process_video_url))
        dp.add_handler(MessageHandler(Filters.text & ~Filters.command, process_video_url))
        dp.add_handler(MessageHandler(Filters.video | Filters.document.mime_type("video/*"), handle_video_file))
        
        # Error handler
        dp.add_error_handler(error_handler)
        
        print('‚úÖ Bot is running... Press Ctrl+C to stop.')
        updater.start_polling()
        updater.idle()
        
    except Exception as e:
        print(f'‚ùå Failed to start bot: {e}')

if __name__ == '__main__':
    main()
